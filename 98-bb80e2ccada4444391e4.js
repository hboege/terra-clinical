(window.webpackJsonp=window.webpackJsonp||[]).push([[98],{1201:function(e,n){},1289:function(e){e.exports=JSON.parse('{"name":"terra-clinical-data-grid","main":"lib/DataGrid.js","version":"2.12.0","description":"An organizational component that renders a collection of data in a grid-like format.","repository":{"type":"git","url":"git+https://github.com/cerner/terra-clinical.git"},"keywords":["Cerner","Terra","Clinical","terra-clinical-data-grid","DataGrid","UI"],"author":"Cerner Corporation","license":"Apache-2.0","bugs":{"url":"https://github.com/cerner/terra-clinical/issues"},"homepage":"https://github.com/cerner/terra-clinical#readme","peerDependencies":{"react":"^16.8.5","react-dom":"^16.8.5","react-intl":"^2.8.0"},"devDependencies":{"terra-props-table":"^2.0.0"},"dependencies":{"classnames":"^2.2.5","keycode-js":"^1.0.4","memoize-one":"^4.0.0","prop-types":"^15.5.8","react-draggable":"^3.0.5","resize-observer-polyfill":"^1.4.1","terra-button":"^3.0.0","terra-clinical-item-view":"^3.9.0","terra-content-container":"^3.0.0","terra-doc-template":"^2.0.0","terra-icon":"^3.0.0","terra-mixins":"^1.0.0","terra-overlay":"^3.0.0"},"scripts":{"compile":"babel --root-mode upward src --out-dir lib --copy-files","lint":"npm run lint:js && npm run lint:scss","lint:js":"eslint --ext .js,.jsx . --ignore-path ../../.eslintignore","lint:scss":"stylelint src/**/*.scss","precompile":"rm -rf lib","test":"npm run jest && npm run wdio","jest":"jest --config ../../jestconfig.js","wdio":"cd ../.. && npx wdio ./packages/$npm_package_name/wdio.conf.js"}}')},1796:function(e,n,t){"use strict";t.r(n),n.default="# Terra Clinical DataGrid\n\nThe DataGrid is an organizational component that renders a collection of data in a grid-like format.\n\n## Getting Started\n\n- Install with [npmjs](https://www.npmjs.com):\n  - `npm install terra-clinical-data-grid`\n\n## Usage\n\nThe DataGrid is a fully-controlled component that utilizes no internal state. Any desired changes to the DataGrid after its initial render can and should be communicated through its props.\n\nContent is provided to the DataGrid as one of four distinct data structures: columns, sections, rows, and cells. These strutures are simple JS objects, not React components. Immutable objects should be used where possible to avoid unnecessary rendering costs.\n\n### Columns\n\nColumns define what is rendered in the column header as well as what interactions are available.\n\nColumns are provided to the DataGrid through two props: `pinnedColumns` and `overflowColumns`. The order in which the columns are provided will be the order in which they are rendered, with the `pinnedColumns` preceeding the `overflowColumns`.\n\n|Name|Type|Is Required|Default Value|Description|\n|---|---|---|---|---|\n|**id**|string|required|none|An identifier for the column. This identifier should be unique across the set of columns provided to the DataGrid.|\n|**width**|number|optional|none|A number (in px) specifying the width of the column. If not provided, the DataGrid's default column width will be used.|\n|**isSelectable**|bool|optional|none|A boolean indicating whether or not the column header is selectable. If true, the DataGrid's `onColumnSelect` prop will be called upon column header selection.|\n|**isResizable**|bool|optional|none|A boolean indicating whether or not the column header is resizable. If true, a resize indicator will be rendered over the column header's contents, and the DataGrid's `onRequestColumnResize` function will be called upon interaction with the resize indicator. The new width will be provided with the function call so that the column's width property can be updated as needed.|\n|**text**|string|optional|none|A string of text to render within the column header. This text will follow standard truncation rules as necessary. If a `component` value is specified, `text` will be ignored.|\n|**sortIndicator**|One of: **ascending**, **descending**|optional|none|A string indicating which sorting indicator should be rendered. If not provided, no sorting indicator will be rendered. If a `component` value is specified, `sortIndicator` will be ignored.\n|**component**|component|optional|none|A custom component to render within the column header. If provided, the `text` and `sortIndicator` values will be ignored.|\n\n### Sections\n\nSections define the rendering style of the section header as well as the rows inside the section.\n\nSections are provided to the DataGrid through the `sections` prop. The order in which the sections are provided will be the order in which they are rendered.\n\n|Name|Type|Is Required|Default Value|Description|\n|---|---|---|---|---|\n|**id**|string|required|none|An identifier for the section. This identifier should be unique across the set of sections provided to the DataGrid.|\n|**isCollapsible**|bool|optional|none|A boolean indicating whether or not the the section is collapsible. If true, the DataGrid's `onRequestSectionCollapse` function will be called upon selection of the section header, and an icon indicating collapsibility will be rendered within the seaction header.|\n|**isCollapsed**|bool|optional|none|A boolean indicating whether or not the section is collapsed. If true, the DataGrid will not render the contents of the section.|\n|**text**|string|optional|none|A text string to render within the section header.|\n|**startAccessory**|component|optional|none|A component to render within the section header's start accessory position. This will be rendered ahead of `text`.|\n|**endAccessory**|component|optional|none|A component to render within the section header's end accessory position. This will be rendered behind `text`.|\n|**component**|component|optional|none|A custom component to render within the section header. If provided, the `text`, `startAccessory`, and `endAccessory` values will be ignored.|\n|**rows**|array|optional|[]|An array of row objects to be rendered within the section.|\n\n> Note: if `text`, `startAccessory`, `endAccessory`, and `component` are not provided, and if `isCollapsible` is false, no section header will be rendered. However, the `rows` of the section will continue to be rendered.\n\nSection headers will be provided the attribute `data-terra-clinical-data-grid-section-header-id=\"${sectionId}` for interested consumers.\n\n### Rows\n\nRows define the cells rendered within the row as well as the row's selection properties.\n\nRows are provided to sections to be rendered by the DataGrid. The order in which the rows are provided will be the order in which they are rendered.\n\n|Name|Type|Is Required|Default Value|Description|\n|---|---|---|---|---|\n|**id**|string|required|none|An identifier for the row. This identifier should be unique across the set of rows provided to a given section.|\n|**ariaLabel**|string|optional|none|A string identifier used to describe the row contents. This value will be used to contruct additional labels for internal controls (e.g. row selection cells).|\n|**isSelectable**|bool|optional|none|A boolean indicating whether or not the row is selectable.|\n|**isSelected**|bool|optional|none|A boolean indicating whether or not the row should render as selected.|\n|**cells**|array|optional|[]|An array of cell objects that define the content to be rendered in the row. The order in which the cells are rendered is determined by the order of the `pinnedColumns` and `overflowColumns` props.|\n|**height**|string|optional|none|The height for this row. This overrides the `DataGrid` `rowHeight` property. Values are suggested to be in `rem`s (ex `'5rem'`), but any valid CSS height value is accepted.|\n\n### Cells\n\nCells define the content rendered in a given section, row, and column.\n\n|Name|Type|Is Required|Default Value|Description|\n|---|---|---|---|---|\n|**columnId**|string|required|none|A column identifier for the cell. This identifier should be unique across the set of cells provided to a given row.|\n|**isSelectable**|bool|optional|none|A boolean indicating whether or not the cell is selectable.|\n|**isSelected**|bool|optional|none|A boolean indicating whether or not the cell should render as selected.|\n|**component**|component|optional|none|A component to render within the cell.|\n\n#### Creating components for Cells\n\nThe DataGrid will provide a explicitly sized container within which the Cell `component` will be rendered. A height and width of `100%` should be set on the component to ensure it fills the available area.\n\n## Creating Custom Content\n\nThe various DataGrid containers (column header, section header, cell) support the presentation of custom components. However, there are a few rules that a component must adhere to.\n\nThe DataGrid provides a number of styles for mouse/keyboard interaction states (click, hover, selection). Custom components should generally render with a transparent background to ensure those default styles bleed through the component.\n\nThe DataGrid will provide a explicitly sized container within which the component will rendered. A height and width of `100%` should be set on the component to ensure it fills the area provided to it.\n\nIf there are any mouse/keyboard interactive elements within the component, and the component is rendered inside a selectable DataGrid container (column header, section header, cell), events may propagate in ways that the component is not expecting. Events triggered by those interactive elements should not be propagated to prevent undesired DataGrid interactions.\n\nAdditionally, these interactive elements must include a special data attribute called `data-accessible-data-grid-content`. The DataGrid utilizes a custom tabbing implementation to ensure a propper tabbing order, and including that attribute on all interactive elements of custom components will ensure that they are still sensibly keyboard accessible.\n\n## Component Features\n* [Cross-Browser Support](https://github.com/cerner/terra-ui/blob/master/src/terra-dev-site/contributing/ComponentStandards.e.contributing.md#cross-browser-support)\n* [Responsive Support](https://github.com/cerner/terra-ui/blob/master/src/terra-dev-site/contributing/ComponentStandards.e.contributing.md#responsive-support)\n"},1797:function(e,n,t){"use strict";t.r(n),n.default="import React from 'react';\nimport PropTypes from 'prop-types';\nimport classNames from 'classnames/bind';\nimport memoize from 'memoize-one';\nimport ResizeObserver from 'resize-observer-polyfill';\nimport ContentContainer from 'terra-content-container';\nimport { injectIntl, intlShape, FormattedMessage } from 'react-intl';\n\nimport KeyCode from 'keycode-js';\nimport Cell from './subcomponents/Cell';\nimport HeaderCell from './subcomponents/HeaderCell';\nimport RowSelectionCell from './subcomponents/RowSelectionCell';\nimport Row from './subcomponents/Row';\nimport Scrollbar from './subcomponents/Scrollbar';\nimport SectionHeader from './subcomponents/SectionHeader';\n\nimport dataGridUtils from './utils/dataGridUtils';\n\nimport { columnDataShape, SortIndicators as ColumnSortIndicators } from './proptypes/columnDataShape';\nimport sectionDataShape from './proptypes/sectionDataShape';\n\nimport styles from './DataGrid.module.scss';\nimport rowStyles from './subcomponents/Row.module.scss';\n\nconst cx = classNames.bind(styles);\nconst cxRow = classNames.bind(rowStyles);\n\nconst propTypes = {\n  /**\n   * String that will be used to identify the DataGrid. This value will be used as the id attribute of the overall DataGrid container,\n   * and it will be used to prefix other id attributes used for internal componentry.\n   */\n  id: PropTypes.string.isRequired,\n  /**\n   * Data for columns that will be pinned. Columns will be presented in the order given.\n   */\n  pinnedColumns: PropTypes.arrayOf(columnDataShape),\n  /**\n   * Data for columns that will be rendered in the DataGrid's horizontal overflow. Columns will be presented in the order given.\n   */\n  overflowColumns: PropTypes.arrayOf(columnDataShape),\n  /**\n   * Data for content in the body of the DataGrid. Sections will be rendered in the order given.\n   */\n  sections: PropTypes.arrayOf(sectionDataShape),\n  /**\n   * Function that is called when a selectable cell is selected. Parameters: `onCellSelect(sectionId, rowId, columnId)`\n   */\n  onCellSelect: PropTypes.func,\n  /**\n   * Function that is called when a selectable header cell is selected. Parameters: `onColumnSelect(columnId)`\n   */\n  onColumnSelect: PropTypes.func,\n  /**\n   * Function that is called when a resizable column is resized. Parameters: `onRequestColumnResize(columnId, requestedWidth)`\n   */\n  onRequestColumnResize: PropTypes.func,\n  /**\n   * Function that is called when a collapsible section is selected. Parameters: `onRequestSectionCollapse(sectionId)`\n   */\n  onRequestSectionCollapse: PropTypes.func,\n  /**\n   * String that specifies the row height. Values are suggested to be in `rem`s (ex `'5rem'`), but any valid CSS height value is accepted.\n   * This value can be overridden for a row by specifying a height on the given row.\n   */\n  rowHeight: PropTypes.string,\n  /**\n   * String that specifies the DataGrid header height. Values are suggested to be in `rem`s (ex `'5rem'`), but any valid CSS height value is accepted.\n   */\n  headerHeight: PropTypes.string,\n  /**\n   * Boolean indicating whether or not the DataGrid should allow entire rows to be selectable. An additional column will be\n   * rendered to allow for row selection to occur.\n   */\n  hasSelectableRows: PropTypes.bool,\n  /**\n   * Function that will be called when a row is selected. Parameters: `onRowSelect(sectionId, rowId)`\n   */\n  onRowSelect: PropTypes.func,\n  /**\n   * Boolean indicating whether or not resizable columns are enabled for the DataGrid. If this prop is not enabled, the isResizable value of columns\n   * will be ignored.\n   */\n  hasResizableColumns: PropTypes.bool,\n  /**\n   * Number indicating the default column width in px. This value will be used if no overriding width value is provided on a per-column basis.\n   */\n  defaultColumnWidth: PropTypes.number,\n  /**\n   * Function that will be called when the DataGrid's vertical overflow reaches its terminal position. This can be used to contextually\n   * load additional content in the DataGrid. If there is no additional content to present, this function should not be provided.\n   * The `fill` prop must also be provided as true; otherwise, the DataGrid will not overflow internally and will not know to request more content.\n   * Parameters: `onRequestContent()`\n   */\n  onRequestContent: PropTypes.func,\n  /**\n   * Boolean that indicates whether or not the DataGrid should fill its parent container.\n   */\n  fill: PropTypes.bool,\n  /**\n   * The intl object containing translations. This is retrieved from the context automatically by injectIntl.\n   */\n  intl: intlShape.isRequired,\n};\n\nconst defaultProps = {\n  pinnedColumns: [],\n  overflowColumns: [],\n  rowHeight: '2.5rem',\n  headerHeight: '2.5rem',\n  defaultColumnWidth: 200,\n  sections: [],\n};\n\n/* eslint-disable react/sort-comp, react/forbid-dom-props */\nclass DataGrid extends React.Component {\n  /**\n   * Returns a new state object containing the pinned/overflowed section widths based on the incoming props.\n   * @param {Object} nextProps Object conforming to DataGrid's prop types.\n   */\n  static getDerivedStateFromProps(nextProps) {\n    return {\n      pinnedColumnWidth: dataGridUtils.getTotalColumnWidth(dataGridUtils.getPinnedColumns(nextProps), nextProps.defaultColumnWidth),\n      overflowColumnWidth: dataGridUtils.getTotalColumnWidth(dataGridUtils.getOverflowColumns(nextProps), nextProps.defaultColumnWidth),\n    };\n  }\n\n  constructor(props) {\n    super(props);\n\n    /**\n     * Accessibility\n     */\n    this.handleLeadingFocusAnchorFocus = this.handleLeadingFocusAnchorFocus.bind(this);\n    this.handleTerminalFocusAnchorFocus = this.handleTerminalFocusAnchorFocus.bind(this);\n\n    /**\n     * Column Sizing\n     */\n    this.updateColumnWidth = this.updateColumnWidth.bind(this);\n\n    /**\n     * Keyboard Events\n     */\n    this.handleKeyDown = this.handleKeyDown.bind(this);\n    this.handleKeyUp = this.handleKeyUp.bind(this);\n    this.shiftIsPressed = false;\n\n    /**\n     * Memoized Style Generators\n     */\n    this.generateHeaderContainerStyle = memoize(this.generateHeaderContainerStyle);\n    this.generateOverflowColumnHeaderStyle = memoize(this.generateOverflowColumnHeaderStyle);\n    this.generatePinnedContainerWidthStyle = memoize(this.generatePinnedContainerWidthStyle);\n    this.generatePinnedColumnHeaderStyle = memoize(this.generatePinnedColumnHeaderStyle);\n\n    /**\n     * Paging\n     */\n    this.checkForMoreContent = this.checkForMoreContent.bind(this);\n\n    /**\n     * Post-render Updates\n     */\n    this.postRenderUpdate = this.postRenderUpdate.bind(this);\n\n    /**\n     * Refs\n     */\n    this.setDataGridContainerRef = this.setDataGridContainerRef.bind(this);\n    this.setHeaderOverflowContainerRef = this.setHeaderOverflowContainerRef.bind(this);\n    this.setHeaderScrollbarBufferRef = this.setHeaderScrollbarBufferRef.bind(this);\n    this.setHorizontalOverflowContainerRef = this.setHorizontalOverflowContainerRef.bind(this);\n    this.setLeadingFocusAnchorRef = this.setLeadingFocusAnchorRef.bind(this);\n    this.setOverflowedContentContainerRef = this.setOverflowedContentContainerRef.bind(this);\n    this.setPinnedContentContainerRef = this.setPinnedContentContainerRef.bind(this);\n    this.setScrollbarRef = this.setScrollbarRef.bind(this);\n    this.setScrollbarContainerRef = this.setScrollbarContainerRef.bind(this);\n    this.setTerminalFocusAnchorRef = this.setTerminalFocusAnchorRef.bind(this);\n    this.setVerticalOverflowContainerRef = this.setVerticalOverflowContainerRef.bind(this);\n    this.cellRefs = {};\n    this.headerCellRefs = {};\n    this.sectionRefs = {};\n\n    /**\n     * Resize Events\n     */\n    this.handleDataGridResize = this.handleDataGridResize.bind(this);\n    this.resizeSectionHeaders = this.resizeSectionHeaders.bind(this);\n    this.updateHeaderScrollbarBuffer = this.updateHeaderScrollbarBuffer.bind(this);\n\n    /**\n     * Scroll synchronization\n     */\n    this.synchronizeHeaderScroll = this.synchronizeHeaderScroll.bind(this);\n    this.synchronizeContentScroll = this.synchronizeContentScroll.bind(this);\n    this.synchronizeScrollbar = this.synchronizeScrollbar.bind(this);\n    this.resetHeaderScrollEventMarkers = this.resetHeaderScrollEventMarkers.bind(this);\n    this.resetContentScrollEventMarkers = this.resetContentScrollEventMarkers.bind(this);\n    this.resetScrollbarEventMarkers = this.resetScrollbarEventMarkers.bind(this);\n    this.updateScrollbarPosition = this.updateScrollbarPosition.bind(this);\n    this.updateScrollbarVisibility = this.updateScrollbarVisibility.bind(this);\n    this.scrollbarPosition = 0;\n\n    /**\n     * Rendering\n     */\n    this.renderCell = this.renderCell.bind(this);\n    this.renderHeaderCell = this.renderHeaderCell.bind(this);\n    this.renderRowSelectionCell = this.renderRowSelectionCell.bind(this);\n    this.renderFixedHeaderRow = this.renderFixedHeaderRow.bind(this);\n    this.renderOverflowContent = this.renderOverflowContent.bind(this);\n    this.renderPinnedContent = this.renderPinnedContent.bind(this);\n    this.renderRow = this.renderRow.bind(this);\n    this.renderScrollbar = this.renderScrollbar.bind(this);\n    this.renderSection = this.renderSection.bind(this);\n    this.renderSectionHeader = this.renderSectionHeader.bind(this);\n\n    /**\n     * Animation Frame ID's\n     */\n    this.animationFrameIDPinned = null;\n    this.animationFrameIDVertical = null;\n\n    /**\n     * Determining the widths of the pinned and overflow sections requires iterating over the prop arrays. The widths are\n     * generated and cached in state to limit the amount of iteration performed by the render functions.\n     */\n    this.state = {\n      pinnedColumnWidth: dataGridUtils.getTotalColumnWidth(dataGridUtils.getPinnedColumns(props), props.defaultColumnWidth),\n      overflowColumnWidth: dataGridUtils.getTotalColumnWidth(dataGridUtils.getOverflowColumns(props), props.defaultColumnWidth),\n    };\n  }\n\n  componentDidMount() {\n    /**\n     * A ResizeObserver is used to manage changes to the DataGrid's overall size. The handler will execute once upon the start of\n     * observation and on every subsequent resize.\n     */\n    this.resizeObserver = new ResizeObserver((entries) => {\n      this.animationFrameIDVertical = window.requestAnimationFrame(() => {\n        this.handleDataGridResize(entries[0].contentRect.width, entries[0].contentRect.height);\n      });\n    });\n    this.resizeObserver.observe(this.verticalOverflowContainerRef);\n\n    /**\n     * Another ResizeObserver is used to track changes to the pinned column section height.\n     */\n    this.pinnedColumnResizeObserver = new ResizeObserver((entries) => {\n      if (this.scrollbarRef) {\n        this.animationFrameIDPinned = window.requestAnimationFrame(() => {\n          /**\n           * The height of the overflow content region must be set to hide the horizontal scrollbar for that element. It is hidden because we\n           * want defer to the custom scrollbar that rendered by the DataGrid.\n           */\n          this.overflowedContentContainerRef.style.height = `${entries[0].contentRect.height}px`;\n        });\n      }\n    });\n    this.pinnedColumnResizeObserver.observe(this.pinnedContentContainerRef);\n\n    /**\n     * We need to keep track of the user's usage of SHIFT to properly handle tabbing paths.\n     */\n    document.addEventListener('keydown', this.handleKeyDown);\n    document.addEventListener('keyup', this.handleKeyUp);\n\n    this.postRenderUpdate();\n  }\n\n  componentDidUpdate(prevProps) {\n    /**\n     * If the sections prop has been updated, we invalidate the content request flag before potentially requesting\n     * more content.\n     */\n    if (prevProps.sections !== this.props.sections) {\n      this.hasRequestedContent = false;\n    }\n\n    this.postRenderUpdate();\n  }\n\n  componentWillUnmount() {\n    window.cancelAnimationFrame(this.animationFrameIDVertical);\n    this.resizeObserver.disconnect(this.verticalOverflowContainerRef);\n    window.cancelAnimationFrame(this.animationFrameIDPinned);\n    this.pinnedColumnResizeObserver.disconnect(this.pinnedContentContainerRef);\n\n    document.removeEventListener('keydown', this.handleKeyDown);\n    document.removeEventListener('keyup', this.handleKeyUp);\n\n    /**\n     * If the component is unmounting, we need to cancel any post-render manipulation before the DOM elements\n     * go out of scope.\n     */\n    cancelAnimationFrame(this.postRenderUpdateAnimationFrame);\n    cancelAnimationFrame(this.scrollSyncAnimationFrame);\n  }\n\n  /**\n   * Accessibility\n   */\n  handleLeadingFocusAnchorFocus() {\n    if (!this.shiftIsPressed) {\n      const firstAccessibleElement = this.dataGridContainerRef.querySelector('[data-accessibility-id=\"0\"]');\n      if (firstAccessibleElement) {\n        firstAccessibleElement.focus();\n      }\n    }\n  }\n\n  handleTerminalFocusAnchorFocus() {\n    if (this.shiftIsPressed) {\n      const lastAccessibleElement = this.dataGridContainerRef.querySelector(`[data-accessibility-id=\"${this.accessibilityStack.length - 1}\"]`);\n\n      if (lastAccessibleElement) {\n        lastAccessibleElement.focus();\n      }\n    }\n  }\n\n  /**\n   * Column Sizing\n   */\n  updateColumnWidth(columnId, widthDelta) {\n    const { onRequestColumnResize, defaultColumnWidth } = this.props;\n\n    if (!onRequestColumnResize) {\n      return;\n    }\n\n    const pinnedColumns = dataGridUtils.getPinnedColumns(this.props);\n    let columnToUpdate;\n    let columnIsPinned;\n    const allColumns = pinnedColumns.concat(dataGridUtils.getOverflowColumns(this.props));\n    for (let i = 0, numberOfColumns = allColumns.length; i < numberOfColumns; i += 1) {\n      if (allColumns[i].id === columnId) {\n        columnToUpdate = allColumns[i];\n\n        if (i < pinnedColumns.length) {\n          columnIsPinned = true;\n        }\n      }\n    }\n\n    if (!columnToUpdate) {\n      return;\n    }\n\n    /**\n     * Depending on the page's layout direction, we need to manipulate the size calculation to account for\n     * the delta's direction-agnostic value.\n     */\n    const pageDirection = document.documentElement.getAttribute('dir');\n    const deltaForDirection = pageDirection === 'rtl' ? widthDelta * -1 : widthDelta;\n    let newWidth = dataGridUtils.getWidthForColumn(columnToUpdate, defaultColumnWidth) + deltaForDirection;\n\n    /**\n     * If the column being updated is a pinned column, we need to ensure that the new width will not cause the pinned columns to overflow the\n     * container's current width. Otherwise, the DataGrid may get into an unrecoverable state.\n     */\n    if (columnIsPinned) {\n      const totalPinnedSectionWidth = pinnedColumns.reduce((totalWidth, pinnedColumn) => {\n        if (pinnedColumn.id === columnId) {\n          return totalWidth + newWidth;\n        }\n\n        return totalWidth + pinnedColumn.width;\n      }, 0);\n\n      const containerWidth = this.dataGridContainerRef.getBoundingClientRect().width;\n      if (totalPinnedSectionWidth > containerWidth) {\n        newWidth -= totalPinnedSectionWidth - containerWidth;\n      }\n    }\n\n    onRequestColumnResize(columnId, newWidth);\n  }\n\n  /**\n   * Keyboard Events\n   */\n  handleKeyDown(event) {\n    if (event.keyCode === KeyCode.KEY_SHIFT) {\n      this.shiftIsPressed = true;\n    }\n\n    if (event.keyCode === KeyCode.KEY_TAB) {\n      const { activeElement } = document;\n\n      if (!activeElement) {\n        return;\n      }\n\n      if (dataGridUtils.matchesSelector(activeElement, '[data-accessibility-id]')) {\n        const currentAccessibilityId = activeElement.getAttribute('data-accessibility-id');\n        const nextAccessibilityId = this.shiftIsPressed ? parseInt(currentAccessibilityId, 10) - 1 : parseInt(currentAccessibilityId, 10) + 1;\n\n        if (nextAccessibilityId >= 0 && nextAccessibilityId < this.accessibilityStack.length) {\n          const nextFocusElement = this.dataGridContainerRef.querySelector(`[data-accessibility-id=\"${nextAccessibilityId}\"]`);\n          if (nextFocusElement) {\n            event.preventDefault();\n            nextFocusElement.focus();\n          }\n        } else if (nextAccessibilityId === -1) {\n          this.leadingFocusAnchorRef.focus();\n        } else {\n          this.terminalFocusAnchorRef.focus();\n        }\n      }\n    }\n  }\n\n  handleKeyUp(event) {\n    if (event.keyCode === KeyCode.KEY_SHIFT) {\n      this.shiftIsPressed = false;\n    }\n  }\n\n  /**\n   * Memoized Style Generators\n   *\n   * These functions could technically be static functions on the DataGrid class, but then the cached values would\n   * be shared across all DataGrid instances. It is recommended to make instance-based versions. Because of this,\n   * the eslint rule for the usage of 'this' must be disabled.\n   */\n\n  /* eslint-disable class-methods-use-this */\n  generateHeaderContainerStyle(headerHeight) {\n    return {\n      height: `${headerHeight}`,\n    };\n  }\n\n  generateOverflowColumnHeaderStyle(overflowColumnWidth, headerHeight) {\n    return {\n      width: `${overflowColumnWidth}px`,\n      height: `${headerHeight}`,\n    };\n  }\n\n  generatePinnedColumnHeaderStyle(pinnedColumnWidth, headerHeight) {\n    return {\n      width: `${pinnedColumnWidth}px`,\n      height: `${headerHeight}`,\n    };\n  }\n\n  generatePinnedContainerWidthStyle(pinnedColumnWidth) {\n    return {\n      width: `${pinnedColumnWidth}px`,\n    };\n  }\n\n  /* eslint-enable class-methods-use-this */\n\n  /**\n   * Paging\n   */\n  checkForMoreContent() {\n    const { onRequestContent } = this.props;\n\n    if (!onRequestContent || this.hasRequestedContent) {\n      return;\n    }\n\n    const containerHeight = this.verticalOverflowContainerRef.getBoundingClientRect().height;\n    const containerScrollHeight = this.verticalOverflowContainerRef.scrollHeight;\n    const containerScrollTop = this.verticalOverflowContainerRef.scrollTop;\n\n    if (containerScrollHeight - (containerScrollTop + containerHeight) <= dataGridUtils.PAGED_CONTENT_OFFSET_BUFFER) {\n      this.hasRequestedContent = true;\n      onRequestContent();\n    }\n  }\n\n  /**\n   * Post-render Updates\n   */\n  postRenderUpdate() {\n    /**\n     * The DOM is parsed after rendering to generate the accessibility identifiers used by the DataGrid's custom\n     * focus implementation.\n     */\n    this.accessibilityStack = dataGridUtils.generateAccessibleContentIndex(this.props, this.headerCellRefs, this.sectionRefs, this.cellRefs);\n\n    /**\n     * The previous animation frame is canceled if it is still pending.\n     */\n    cancelAnimationFrame(this.postRenderUpdateAnimationFrame);\n\n    this.postRenderUpdateAnimationFrame = requestAnimationFrame(() => {\n      /**\n       * The SectionHeader widths must be updated after rendering to match the rendered DataGrid's width.\n       */\n      this.resizeSectionHeaders(this.verticalOverflowContainerRef.clientWidth);\n\n      /**\n       * The scrollbar position and visibility are determined based on the size of the DataGrid after rendering.\n       */\n      this.updateScrollbarPosition();\n      this.updateScrollbarVisibility();\n\n      /**\n       * Ensure correct padding is set on the header to account for potentially increased row counts.\n       */\n      this.updateHeaderScrollbarBuffer();\n\n      if (this.scrollbarRef) {\n        /**\n         * The height of the overflow content region must be set to hide the horizontal scrollbar for that element. It is hidden because we\n         * want defer to the custom scrollbar that rendered by the DataGrid.\n         */\n        this.overflowedContentContainerRef.style.height = `${this.pinnedContentContainerRef.getBoundingClientRect().height}px`;\n      }\n\n      this.checkForMoreContent();\n    });\n  }\n\n  /**\n   * Refs\n   */\n  setDataGridContainerRef(ref) {\n    this.dataGridContainerRef = ref;\n  }\n\n  setPinnedContentContainerRef(ref) {\n    this.pinnedContentContainerRef = ref;\n  }\n\n  setHeaderOverflowContainerRef(ref) {\n    this.headerOverflowContainerRef = ref;\n  }\n\n  setHeaderScrollbarBufferRef(ref) {\n    this.headerScrollbarBufferRef = ref;\n  }\n\n  setHorizontalOverflowContainerRef(ref) {\n    this.horizontalOverflowContainerRef = ref;\n  }\n\n  setLeadingFocusAnchorRef(ref) {\n    this.leadingFocusAnchorRef = ref;\n  }\n\n  setOverflowedContentContainerRef(ref) {\n    this.overflowedContentContainerRef = ref;\n  }\n\n  setScrollbarRef(ref) {\n    this.scrollbarRef = ref;\n  }\n\n  setScrollbarContainerRef(ref) {\n    this.scrollbarContainerRef = ref;\n  }\n\n  setTerminalFocusAnchorRef(ref) {\n    this.terminalFocusAnchorRef = ref;\n  }\n\n  setVerticalOverflowContainerRef(ref) {\n    this.verticalOverflowContainerRef = ref;\n  }\n\n  /**\n   * Resize Events\n   */\n  handleDataGridResize(newWidth) {\n    this.resizeSectionHeaders(newWidth);\n    this.updateHeaderScrollbarBuffer();\n    this.updateScrollbarPosition();\n    this.updateScrollbarVisibility();\n    this.checkForMoreContent();\n  }\n\n  resizeSectionHeaders(width) {\n    /**\n     * The widths are applied directly the nodes (outside of the React rendering lifecycle) to improve performance and limit\n     * unnecessary rendering of other components.\n     */\n    const sectionHeaderContainers = this.dataGridContainerRef.querySelectorAll(`.${cx('pinned-content-container')} .${cx('section-header-container')}`);\n\n    /**\n     * querySelectorAll returns a NodeList, which does not support standard iteration functions like forEach in legacy browsers.\n     */\n    for (let i = 0, numberOfSectionHeaders = sectionHeaderContainers.length; i < numberOfSectionHeaders; i += 1) {\n      sectionHeaderContainers[i].style.width = `${width}px`; // eslint-disable-line no-param-reassign\n    }\n  }\n\n  updateHeaderScrollbarBuffer() {\n    const { pinnedColumnWidth } = this.state;\n\n    if (!this.headerScrollbarBufferRef) {\n      /**\n       * The buffer element will not be rendered if the 'fill' prop is not provided.\n       * If the ref to the buffer element does not exist, it must not be rendered, so there is no work to do here.\n       */\n      return;\n    }\n\n    /**\n     * If there is a vertical overflow and fixed scrollbars are present (due to the presence of a mouse, etc.), the header columns\n     * and content columns can move out of alignment. We need to account for the potential presence of the scrollbar and set the size of the\n     * header scrollbar buffer element to equalize any differences in width.\n     */\n    const scrollbarOffset = this.dataGridContainerRef.clientWidth - pinnedColumnWidth - this.horizontalOverflowContainerRef.clientWidth;\n    this.headerScrollbarBufferRef.style.width = `${scrollbarOffset}px`;\n  }\n\n  /**\n   * Scroll synchronization\n   */\n  synchronizeHeaderScroll() {\n    if (this.scrollbarIsScrolling || this.contentIsScrolling) {\n      return;\n    }\n\n    this.headerIsScrolling = true;\n\n    if (this.synchronizeScrollTimeout) {\n      clearTimeout(this.synchronizeScrollTimeout);\n    }\n\n    this.synchronizeScrollTimeout = setTimeout(this.resetHeaderScrollEventMarkers, 100);\n\n    cancelAnimationFrame(this.scrollSyncAnimationFrame);\n\n    this.scrollSyncAnimationFrame = requestAnimationFrame(() => {\n      this.horizontalOverflowContainerRef.scrollLeft = this.headerOverflowContainerRef.scrollLeft;\n\n      this.updateScrollbarPosition();\n    });\n  }\n\n  synchronizeContentScroll() {\n    if (this.scrollbarIsScrolling || this.headerIsScrolling) {\n      return;\n    }\n\n    this.contentIsScrolling = true;\n\n    if (this.synchronizeScrollTimeout) {\n      clearTimeout(this.synchronizeScrollTimeout);\n    }\n\n    this.synchronizeScrollTimeout = setTimeout(this.resetContentScrollEventMarkers, 100);\n\n    cancelAnimationFrame(this.scrollSyncAnimationFrame);\n\n    this.scrollSyncAnimationFrame = requestAnimationFrame(() => {\n      this.headerOverflowContainerRef.scrollLeft = this.horizontalOverflowContainerRef.scrollLeft;\n\n      this.updateScrollbarPosition();\n    });\n  }\n\n  synchronizeScrollbar(event, data) {\n    if (this.headerIsScrolling || this.contentIsScrolling) {\n      return;\n    }\n\n    this.scrollbarIsScrolling = true;\n\n    const newPosition = this.scrollbarPosition + data.deltaX;\n    const scrollArea = this.horizontalOverflowContainerRef.clientWidth - this.scrollbarRef.clientWidth;\n\n    let finalPosition;\n    if (newPosition < 0) {\n      finalPosition = 0;\n    } else if (newPosition > scrollArea) {\n      finalPosition = scrollArea;\n    } else {\n      finalPosition = newPosition;\n    }\n\n    this.scrollbarPosition = finalPosition;\n\n    const positionRatio = finalPosition / scrollArea;\n    const maxScrollLeft = this.horizontalOverflowContainerRef.scrollWidth - this.horizontalOverflowContainerRef.clientWidth;\n\n    cancelAnimationFrame(this.scrollSyncAnimationFrame);\n\n    this.scrollSyncAnimationFrame = requestAnimationFrame(() => {\n      this.scrollbarRef.style.transform = `translateX(${this.scrollbarPosition}px)`;\n      this.headerOverflowContainerRef.scrollLeft = maxScrollLeft * positionRatio;\n      this.horizontalOverflowContainerRef.scrollLeft = maxScrollLeft * positionRatio;\n    });\n  }\n\n  resetHeaderScrollEventMarkers() {\n    this.headerIsScrolling = false;\n  }\n\n  resetContentScrollEventMarkers() {\n    this.contentIsScrolling = false;\n  }\n\n  resetScrollbarEventMarkers() {\n    this.scrollbarIsScrolling = false;\n  }\n\n  updateScrollbarVisibility() {\n    if (!this.scrollbarContainerRef) {\n      /**\n       * The scrollbar will not be rendered if the 'fill' prop is not provided.\n       * If the ref to the scrollbar does not exist, it must not be rendered, so there is no work to do here.\n       */\n      return;\n    }\n\n    if (Math.abs(this.horizontalOverflowContainerRef.scrollWidth - this.horizontalOverflowContainerRef.getBoundingClientRect().width) < 1) {\n      this.scrollbarContainerRef.setAttribute('aria-hidden', true);\n    } else {\n      this.scrollbarContainerRef.removeAttribute('aria-hidden');\n    }\n  }\n\n  updateScrollbarPosition() {\n    const { overflowColumnWidth } = this.state;\n\n    if (!this.scrollbarRef) {\n      /**\n       * The scrollbar will not be rendered if the 'fill' prop is not provided.\n       * If the ref to the scrollbar does not exist, it must not be rendered, so there is no work to do here.\n       */\n      return;\n    }\n\n    /**\n     * The scrollbar width is determined by squaring the horizontal container width and dividing by the overflow value. The scrollbar cannot be larger than the container.\n     */\n    const scrollbarWidth = Math.min(this.horizontalOverflowContainerRef.clientWidth, (this.horizontalOverflowContainerRef.clientWidth * this.horizontalOverflowContainerRef.clientWidth) / (overflowColumnWidth));\n\n    /**\n     * The scrollbar position is determined by calculating its position within the horizontalOverflowContainerRef and applying its relative position\n     * to the overall horizontal container width.\n     */\n    const positionRatio = this.horizontalOverflowContainerRef.scrollLeft / (this.horizontalOverflowContainerRef.scrollWidth - this.horizontalOverflowContainerRef.clientWidth);\n    const position = (this.horizontalOverflowContainerRef.clientWidth - scrollbarWidth) * positionRatio;\n\n    this.scrollbarPosition = position;\n    this.scrollbarRef.style.width = `${scrollbarWidth}px`;\n    this.scrollbarRef.style.transform = `translateX(${this.scrollbarPosition}px)`;\n  }\n\n  /**\n   * Rendering\n   */\n  renderHeaderCell(columnData) {\n    const columnId = columnData.id;\n    const { onColumnSelect, hasResizableColumns, defaultColumnWidth } = this.props;\n\n    /**\n     * Rather than render an empty HeaderCell for the void column, we just render nothing.\n     * The width of the void column is already being accounted for.\n     */\n    if (columnId === 'DataGrid-voidColumn') {\n      return undefined;\n    }\n\n    return (\n      <HeaderCell\n        key={columnId}\n        columnId={columnId}\n        text={columnData.text}\n        sortIndicator={columnData.sortIndicator}\n        width={`${dataGridUtils.getWidthForColumn(columnData, defaultColumnWidth)}px`}\n        isSelectable={columnData.isSelectable}\n        isResizable={hasResizableColumns && columnData.isResizable}\n        onResizeEnd={this.updateColumnWidth}\n        onSelect={onColumnSelect}\n        selectableRefCallback={(ref) => { this.headerCellRefs[columnId] = ref; }}\n      >\n        {columnData.component}\n      </HeaderCell>\n    );\n  }\n\n  renderFixedHeaderRow() {\n    const {\n      headerHeight,\n    } = this.props;\n\n    const {\n      pinnedColumnWidth,\n      overflowColumnWidth,\n    } = this.state;\n\n    return (\n      <div\n        className={cx(['header-container', 'fixed'])}\n        style={this.generateHeaderContainerStyle(headerHeight)}\n      >\n        <div\n          className={cx('pinned-header')}\n          style={this.generatePinnedColumnHeaderStyle(pinnedColumnWidth, headerHeight)}\n        >\n          {dataGridUtils.getPinnedColumns(this.props).map(column => this.renderHeaderCell(column))}\n        </div>\n        <div\n          className={cx('header-overflow-container')}\n          ref={this.setHeaderOverflowContainerRef}\n          onScroll={this.synchronizeHeaderScroll}\n        >\n          <div\n            className={cx('overflow-header')}\n            style={this.generateOverflowColumnHeaderStyle(overflowColumnWidth, headerHeight)}\n          >\n            {dataGridUtils.getOverflowColumns(this.props).map(column => this.renderHeaderCell(column))}\n          </div>\n        </div>\n        <div\n          className={cx('header-scrollbar-buffer')}\n          ref={this.setHeaderScrollbarBufferRef}\n        />\n      </div>\n    );\n  }\n\n  renderSectionHeader(section, isPinned) {\n    const { onRequestSectionCollapse } = this.props;\n\n    const shouldRenderSectionHeaderContainer = section.isCollapsible || section.text || section.startAccessory || section.endAccessory || section.component;\n\n    return (\n      shouldRenderSectionHeaderContainer ? (\n        <div\n          key={section.id}\n          className={cx('section-header-container')}\n        >\n          { isPinned ? (\n            <SectionHeader\n              sectionId={section.id}\n              text={section.text}\n              startAccessory={section.startAccessory}\n              endAccessory={section.endAccessory}\n              isCollapsible={section.isCollapsible}\n              isCollapsed={section.isCollapsed}\n              onRequestSectionCollapse={onRequestSectionCollapse}\n              selectableRefCallback={(ref) => {\n                this.sectionRefs[section.id] = ref;\n              }}\n            >\n              {section.component}\n            </SectionHeader>\n          ) : null}\n        </div>\n      ) : null\n    );\n  }\n\n  renderRowSelectionCell(section, row, column) {\n    const { defaultColumnWidth } = this.props;\n    const cellKey = `${section.id}-${row.id}-${column.id}`;\n\n    return (\n      <RowSelectionCell\n        key={cellKey}\n        sectionId={section.id}\n        rowId={row.id}\n        columnId={column.id}\n        width={`${dataGridUtils.getWidthForColumn(column, defaultColumnWidth)}px`}\n        isSelectable={row.isSelectable}\n        isSelected={row.isSelected}\n        onSelect={this.props.onRowSelect}\n        selectableRefCallback={(ref) => { this.cellRefs[cellKey] = ref; }}\n        onHoverStart={\n          () => {\n            /**\n             * Because the pinned and overflow rows are two separate elements, we need to retrieve them and add the appropriate hover styles\n             * to both to ensure a consistent row styling.\n             */\n            const rowElements = this.dataGridContainerRef.querySelectorAll(`[data-row][data-row-id=\"${row.id}\"][data-section-id=\"${section.id}\"]`);\n            for (let i = 0, numberOfRows = rowElements.length; i < numberOfRows; i += 1) {\n              rowElements[i].classList.add(cxRow('hover'));\n            }\n          }\n        }\n        onHoverEnd={\n          () => {\n            const rowElements = this.dataGridContainerRef.querySelectorAll(`[data-row][data-row-id=\"${row.id}\"][data-section-id=\"${section.id}\"]`);\n            for (let i = 0, numberOfRows = rowElements.length; i < numberOfRows; i += 1) {\n              rowElements[i].classList.remove(cxRow('hover'));\n            }\n          }\n        }\n        ariaLabel={this.props.intl.formatMessage({\n          id: 'Terra.data-grid.row-selection-template',\n        }, {\n          'row-description': row.ariaLabel,\n        })}\n      />\n    );\n  }\n\n  renderCell(section, row, column) {\n    const { onCellSelect, defaultColumnWidth } = this.props;\n\n    const cell = (row.cells && row.cells.find(searchCell => searchCell.columnId === column.id)) || {};\n    const cellKey = `${section.id}-${row.id}-${column.id}`;\n\n    return (\n      <Cell\n        key={cellKey}\n        sectionId={section.id}\n        rowId={row.id}\n        columnId={column.id}\n        width={`${dataGridUtils.getWidthForColumn(column, defaultColumnWidth)}px`}\n        onSelect={onCellSelect}\n        isSelectable={cell.isSelectable}\n        isSelected={cell.isSelected}\n        selectableRefCallback={(ref) => { this.cellRefs[cellKey] = ref; }}\n      >\n        {cell.component}\n      </Cell>\n    );\n  }\n\n  renderRow(row, section, columns, width, isPinned, isStriped) {\n    const { id } = this.props;\n    const height = row.height || this.props.rowHeight;\n\n    /**\n     * Because of the DOM structure necessary to properly render the pinned and overflow sections,\n     * each 'row' of the DataGrid is actually two rows, side-by-side. However, we can use aria attributes\n     * to ensure screen readers will read both rows as one contiguous row.\n     */\n    const ariaStyles = {};\n    if (isPinned) {\n      ariaStyles.id = `${id}-Pinned-Row-${row.id}-Section-${section.id}`;\n      ariaStyles['aria-owns'] = `${id}-Overflow-Row-${row.id}-Section-${section.id}`;\n    } else {\n      ariaStyles.id = `${id}-Overflow-Row-${row.id}-Section-${section.id}`;\n    }\n\n    return (\n      <Row\n        key={`${section.id}-${row.id}`}\n        sectionId={section.id}\n        rowId={row.id}\n        width={width}\n        height={height}\n        isSelected={row.isSelected}\n        isStriped={isStriped}\n        {...ariaStyles}\n\n      >\n        {columns.map((column) => {\n          if (column.id === 'DataGrid-rowSelectionColumn') {\n            return this.renderRowSelectionCell(section, row, column);\n          }\n\n          if (column.id === 'DataGrid-voidColumn') {\n            return undefined;\n          }\n\n          return this.renderCell(section, row, column);\n        })}\n      </Row>\n    );\n  }\n\n  renderSection(section, columns, width, isPinned) {\n    return (\n      <React.Fragment key={section.id}>\n        {this.renderSectionHeader(section, isPinned)}\n        {!section.isCollapsed && section.rows && section.rows.map((row, index) => (\n          this.renderRow(row, section, columns, width, isPinned, !!(index % 2))\n        ))}\n      </React.Fragment>\n    );\n  }\n\n  renderPinnedContent() {\n    const { headerHeight, fill, sections } = this.props;\n    const { pinnedColumnWidth } = this.state;\n\n    return (\n      <React.Fragment>\n        {!fill && (\n          <div className={cx('header-container')} style={this.generatePinnedColumnHeaderStyle(pinnedColumnWidth, headerHeight)}>\n            <div className={cx('pinned-header')}>\n              {dataGridUtils.getPinnedColumns(this.props).map(column => this.renderHeaderCell(column))}\n            </div>\n          </div>\n        )}\n        {sections.map(section => this.renderSection(section, dataGridUtils.getPinnedColumns(this.props), `${pinnedColumnWidth}px`, true))}\n      </React.Fragment>\n    );\n  }\n\n  renderOverflowContent() {\n    const { headerHeight, fill, sections } = this.props;\n    const { overflowColumnWidth } = this.state;\n\n    return (\n      <React.Fragment>\n        {!fill && (\n          <div className={cx('header-container')} style={this.generateOverflowColumnHeaderStyle(overflowColumnWidth, headerHeight)}>\n            <div className={cx('overflow-header')}>\n              {dataGridUtils.getOverflowColumns(this.props).map(column => this.renderHeaderCell(column))}\n            </div>\n          </div>\n        )}\n        {sections.map(section => this.renderSection(section, dataGridUtils.getOverflowColumns(this.props), `${overflowColumnWidth}px`))}\n      </React.Fragment>\n    );\n  }\n\n  renderScrollbar() {\n    const { pinnedColumnWidth } = this.state;\n\n    return (\n      <div className={cx('footer-container')}>\n        <div\n          className={cx('pinned-column-buffer')}\n          style={this.generatePinnedContainerWidthStyle(pinnedColumnWidth)}\n        />\n        <div className={cx('scrollbar-container')}>\n          <Scrollbar\n            refCallback={this.setScrollbarContainerRef}\n            scrollbarRefCallback={this.setScrollbarRef}\n            onMove={this.synchronizeScrollbar}\n            onMoveEnd={this.resetScrollbarEventMarkers}\n          />\n        </div>\n      </div>\n    );\n  }\n\n  render() {\n    const {\n      id,\n      pinnedColumns,\n      overflowColumns,\n      sections,\n      onCellSelect,\n      onColumnSelect,\n      onRequestColumnResize,\n      onRequestSectionCollapse,\n      rowHeight,\n      headerHeight,\n      hasSelectableRows,\n      onRowSelect,\n      hasResizableColumns,\n      defaultColumnWidth,\n      fill,\n      onRequestContent,\n      intl,\n      ...customProps\n    } = this.props;\n    const { pinnedColumnWidth } = this.state;\n\n    const dataGridClassnames = cx(['data-grid-container', { fill }, customProps.className]);\n\n    return (\n      <div\n        {...customProps}\n        id={id}\n        className={dataGridClassnames}\n        ref={this.setDataGridContainerRef}\n      >\n        <FormattedMessage id=\"Terra.data-grid.navigate\">\n          {label => (\n            <div\n              role=\"button\"\n              aria-label={label}\n              className={cx('leading-focus-anchor')}\n              tabIndex=\"0\"\n              onFocus={this.handleLeadingFocusAnchorFocus}\n              ref={this.setLeadingFocusAnchorRef}\n            />\n          )}\n        </FormattedMessage>\n        <ContentContainer\n          header={fill ? this.renderFixedHeaderRow() : undefined}\n          footer={fill ? this.renderScrollbar() : undefined}\n          fill={fill}\n        >\n          <div\n            className={cx('vertical-overflow-container')}\n            ref={this.setVerticalOverflowContainerRef}\n            onScroll={onRequestContent ? this.checkForMoreContent : undefined}\n          >\n            <div\n              className={cx('pinned-content-container')}\n              ref={this.setPinnedContentContainerRef}\n              style={this.generatePinnedContainerWidthStyle(pinnedColumnWidth)}\n            >\n              {this.renderPinnedContent()}\n            </div>\n            <div\n              className={cx('overflowed-content-container')}\n              ref={this.setOverflowedContentContainerRef}\n            >\n              <div\n                className={cx(['horizontal-overflow-container', { 'padded-container': fill }])}\n                ref={this.setHorizontalOverflowContainerRef}\n                onScroll={fill ? this.synchronizeContentScroll : undefined}\n              >\n                {this.renderOverflowContent()}\n              </div>\n            </div>\n          </div>\n        </ContentContainer>\n        <FormattedMessage id=\"Terra.data-grid.navigate\">\n          {label => (\n            <div\n              role=\"button\"\n              aria-label={label}\n              className={cx('terminal-focus-anchor')}\n              tabIndex=\"0\"\n              onFocus={this.handleTerminalFocusAnchorFocus}\n              ref={this.setTerminalFocusAnchorRef}\n            />\n          )}\n        </FormattedMessage>\n      </div>\n    );\n  }\n}\n\nDataGrid.propTypes = propTypes;\nDataGrid.defaultProps = defaultProps;\n\nexport default injectIntl(DataGrid);\nexport { ColumnSortIndicators };\n"},1958:function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.default=void 0;var i=l(t(0)),o=l(t(1200)),r=l(t(1796)),s=t(1289),a=l(t(1797));function l(e){return e&&e.__esModule?e:{default:e}}var d=function(){return i.default.createElement(o.default,{packageName:s.name,readme:r.default,srcPath:"https://github.com/cerner/terra-clinical/tree/master/packages/".concat(s.name),propsTables:[{componentName:"DataGrid",componentSrc:a.default}]})};n.default=d}}]);
//# sourceMappingURL=98-bb80e2ccada4444391e4.js.map